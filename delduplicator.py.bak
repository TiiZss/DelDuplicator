# /// script
# dependencies = []
# ///

import os
import hashlib
import sys
from pathlib import Path

# --- CONFIGURACIÓN ---
# Cambia esto a False cuando estés seguro de que quieres borrar los archivos.
MODO_SECO = True 

# Directorio a escanear (puedes cambiarlo aquí o pasarlo como argumento)
DIRECTORIO_DEFAULT = "." 

def calcular_hashes(ruta_archivo):
    """
    Calcula MD5 y SHA1 de un archivo leyendo en bloques
    para no saturar la memoria RAM con archivos grandes.
    """
    hash_md5 = hashlib.md5()
    hash_sha1 = hashlib.sha1()
    
    # Buffer de 64kb
    bloque_size = 65536 
    
    try:
        with open(ruta_archivo, "rb") as f:
            while True:
                bloque = f.read(bloque_size)
                if not bloque:
                    break
                hash_md5.update(bloque)
                hash_sha1.update(bloque)
                
        return hash_md5.hexdigest(), hash_sha1.hexdigest()
    except OSError as e:
        print(f"Error leyendo {ruta_archivo}: {e}")
        return None, None

def escanear_y_eliminar(directorio):
    # Diccionario para guardar los archivos únicos.
    # Clave: (md5, sha1) -> Valor: ruta_archivo_original
    archivos_unicos = {}
    
    contador_duplicados = 0
    espacio_liberado = 0
    
    ruta_base = Path(directorio).resolve()
    
    if not ruta_base.exists():
        print(f"El directorio '{ruta_base}' no existe.")
        return

    print(f"--- Escaneando directorio: {ruta_base} ---")
    print(f"--- Modo de prueba (Dry Run): {'ACTIVADO' if MODO_SECO else 'DESACTIVADO'} ---\n")

    # Recorremos el directorio recursivamente
    for archivo_actual in ruta_base.rglob("*"):
        if not archivo_actual.is_file():
            continue
            
        # Optimización: No calculamos hash si es un enlace simbólico (opcional)
        if archivo_actual.is_symlink():
            continue

        md5, sha1 = calcular_hashes(archivo_actual)
        
        if md5 is None: 
            continue # Hubo un error de lectura

        clave_hash = (md5, sha1)

        if clave_hash in archivos_unicos:
            # ES UN DUPLICADO
            archivo_original = archivos_unicos[clave_hash]
            tamano = archivo_actual.stat().st_size
            
            print(f"[DUPLICADO ENCONTRADO]")
            print(f"  Original: {archivo_original}")
            print(f"  Copia:    {archivo_actual}")
            print(f"  Hashes:   MD5:{md5} / SHA1:{sha1}")
            
            if not MODO_SECO:
                try:
                    os.remove(archivo_actual)
                    print("  Status:   ELIMINADO ✅")
                except OSError as e:
                    print(f"  Status:   ERROR AL BORRAR ({e}) ❌")
            else:
                print("  Status:   Simulación (no borrado) cyj")
            
            contador_duplicados += 1
            espacio_liberado += tamano
            print("-" * 40)
            
        else:
            # ES UN ARCHIVO NUEVO/ÚNICO
            archivos_unicos[clave_hash] = archivo_actual

    # Resumen final
    print("\n--- RESUMEN ---")
    print(f"Archivos únicos encontrados: {len(archivos_unicos)}")
    print(f"Duplicados detectados: {contador_duplicados}")
    bytes_a_mb = espacio_liberado / (1024 * 1024)
    accion = "liberables" if MODO_SECO else "liberados"
    print(f"Espacio {accion}: {bytes_a_mb:.2f} MB")

if __name__ == "__main__":
    # Configurar salida estándar a UTF-8 explícitamente para consola de Windows
    sys.stdout.reconfigure(encoding='utf-8')
    
    target = sys.argv[1] if len(sys.argv) > 1 else DIRECTORIO_DEFAULT
    escanear_y_eliminar(target)